
use serde::{Serialize, Deserialize};
use rand::Rng;

use super::modifiers::{ModifierTrait, Edge};
use super::utils::{AABBs, PlaneData};

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct WanderNoise {
    pub wander:               Wanders,
    pub width:                f32,
    pub height:               f32,
    pub step:                 f32,
    pub source_edge:          Option<Edge>,
    pub target_edge:          Option<Edge>,
    pub source_point:         Option<(f32, f32)>,
    pub target_point:         Option<(f32, f32)>
}

impl WanderNoise {
    pub fn aabbs(&self, pd: &PlaneData) -> AABBs {
        let aabbs = AABBs::new();

        let mut x: f32 = 0.0;
        let mut y: f32 = 0.0;

        if let Some(source_point) = self.source_point {
            x = source_point.0;
            y = source_point.1;
        }

        // central points of the boxes
        let mut points: Vec<(f32, f32)> = vec![(x,y)];

        // test approach for now
        for _i in 0..=10 {
            let point = self.wander.apply(x,y, self.step);
            points.push(point);
            x = point.0;
            y = point.1;
        }

        println!("points: {:?}", points);

        // TODO: construct aabbs from points
        // Add end conditions -> reached target, max steps, etc.


        return aabbs;
    }
}

impl ModifierTrait for WanderNoise {
    fn apply(&self, pos: &[f32; 3], aabbs: &AABBs) -> f32 {
        if aabbs.has_point(pos) {
            return self.height;
        }
        return pos[1];
    }
}





#[derive(Clone, Copy, Debug, PartialEq, Serialize, Deserialize)]
pub enum Wanders {
    Robot,     // Random Direction n steps, choose random direction n steps
    Zax,       // goes nsew or e, or e or e (in general follows in direction)
    Emu,       // doesnt allow backwards
    Emu90,     // not, grid, steers randomly between 0-90 angle
    Emu60,     // 0-60
    Emu30,     // 0-30
    EmuPerlin, // next angle is generated by perlin
    Wanderer   // nswe, goal goal goal, when you have a start and end point
}

impl Wanders {

    fn apply(&self, x: f32, y: f32, step: f32) -> (f32, f32) {
        let mut new_x: f32 = x;
        let mut new_y: f32 = y;

        match self {
            Wanders::Emu30 => {
                (new_x, new_y) = random_point_in_arc(x,y,step, -0.26 ,0.26);
            }
            _ => {}
        }

        return (new_x, new_y);

    }
}

fn random_point_in_arc(x: f32, y: f32, r: f32, start_angle: f32, end_angle: f32) -> (f32, f32) {
    let mut rng = rand::thread_rng();
    let random_angle = rng.gen_range(start_angle..=end_angle);
    let point_x = x + r * random_angle.cos();
    let point_y = y + r * random_angle.sin();

    (point_x, point_y)
}



// fn get_range(x: f32, y: f32, step: f32){

// }



// // direction in radians
// fn get_direction() -> f32 {



//     return 0.0;

// }


// fn get_random(min: f32, max: f32) -> f32 {
//     let mut rng = rand::thread_rng();
//     return rng.gen_range(min..=max);
// }



